# Advanced-SQL
Проект выполняется в интерактивном тренажере на платформе Яндекс.Практикума

Состоит из 20 заданий на составление запросов к базе данных StackOverflow — сервиса вопросов и ответов о программировании. StackOverflow похож на социальную сеть — пользователи сервиса задают вопросы, отвечают на посты, оставляют комментарии и ставят оценки другим ответам.

ER-диаграмма базы данных:
![stackoverflow-ER-diagram](https://user-images.githubusercontent.com/117563470/210385510-c6d519eb-6850-46ba-81c8-c77efeb98654.png) 

***

Описание данных, которые хранят таблицы:

Таблица `badges`

Хранит информацию о значках, которые присуждаются за разные достижения. Например, пользователь, правильно ответивший на большое количество вопросов про PostgreSQL, может получить значок postgresql. 
* `id` - идентификатор значка, первичный ключ таблицы
* `name` - название значка
* `user_id` - идентификатор пользователя, которому присвоили значок, внешний ключ, отсылающий к таблице users
* `creation_date` - дата присвоения значка

Таблица `post_types`

Содержит информацию о типе постов. Их может быть два:
1. Question — пост с вопросом;
2. Answer — пост с ответом.

* `id` - идентификатор поста, первичный ключ таблицы
* `type` - тип поста

Таблица `posts`

Содержит информацию о постах.
* `id` - идентификатор поста, первичный ключ таблицы
* `title` - заголовок поста
* `creation_date` - дата создания поста
* `favorites_count` - число, которое показывает, сколько раз пост добавили в «Закладки»
* `last_activity_date` - дата последнего действия в посте, например комментария
* `last_edit_date` - дата последнего изменения поста
* `user_id` - идентификатор пользователя, который создал пост, внешний ключ к таблице users
* `parent_id` - если пост написали в ответ на другую публикацию, в это поле попадёт идентификатор поста с вопросом
* `post_type_id` - идентификатор типа поста, внешний ключ к таблице post_types
* `score` - количество очков, которое набрал пост
* `views_count` - количество просмотров

Таблица `users`

Содержит информацию о пользователях.
* `id` - идентификатор пользователя, первичный ключ таблицы
* `creation_date` - дата регистрации пользователя
* `display_name` - имя пользователя
* `last_access_date` - дата последнего входа
* `location` - местоположение
* `reputation` - очки репутации, которые получают за хорошие вопросы и полезные ответы
* `views` - число просмотров профиля пользователя

Таблица `vote_types`

Содержит информацию о типах голосов. Голос — это метка, которую пользователи ставят посту. Типов бывает несколько: 
1. UpMod` — такую отметку получают посты с вопросами или ответами, которые пользователи посчитали уместными и полезными.
2. DownMod — такую отметку получают посты, которые показались пользователям наименее полезными.
3. Close — такую метку ставят опытные пользователи сервиса, если заданный вопрос нужно доработать или он вообще не подходит для платформы.
4. Offensive — такую метку могут поставить, если пользователь ответил на вопрос в грубой и оскорбительной манере, например, указав на неопытность автора поста.
5. Spam — такую метку ставят в случае, если пост пользователя выглядит откровенной рекламой.

* `id` - идентификатор типа голоса, первичный ключ
* `name` - название метки

Таблица `votes`

Содержит информацию о голосах за посты. 
* `id` - идентификатор голоса, первичный ключ
* `post_id` - идентификатор поста, внешний ключ к таблице posts
* `user_id` - идентификатор пользователя, который поставил посту голос, внешний ключ к таблице users
* `bounty_amount` - сумма вознаграждения, которое назначают, чтобы привлечь внимание к посту
* `vote_type_id` - идентификатор типа голоса, внешний ключ к таблице vote_types
* `creation_date` - дата назначения голоса

***

## Задания и решения

**1. Найдите количество вопросов, которые набрали больше 300 очков или как минимум 100 раз были добавлены в «Закладки».**

````sql
SELECT COUNT(id)
FROM stackoverflow.posts 
WHERE post_type_id = 1 AND (score > 300 OR favorites_count >= 100);
````

**2. Сколько в среднем в день задавали вопросов с 1 по 18 ноября 2008 включительно? Результат округлите до целого числа.**

````sql
SELECT ROUND(AVG(q.count))
FROM (
      SELECT COUNT(id),
             creation_date::date 
      FROM stackoverflow.posts
      WHERE post_type_id = 1
      GROUP BY creation_date::date 
      HAVING creation_date::date BETWEEN '2008-11-01' AND '2008-11-18'
) AS q;
````

**3. Сколько пользователей получили значки сразу в день регистрации? Выведите количество уникальных пользователей.**

````sql
SELECT COUNT(DISTINCT u.id)
FROM stackoverflow.users u
JOIN stackoverflow.badges b ON u.id = b.user_id 
WHERE u.creation_date::date  = b.creation_date::date;
````

**4. Сколько уникальных постов пользователя с именем Joel Coehoorn получили хотя бы один голос?**

````sql
SELECT COUNT(cv.id)
FROM (SELECT p.id
      FROM stackoverflow.posts p 
      JOIN stackoverflow.users u ON p.user_id = u.id 
      JOIN stackoverflow.votes v ON p.id = v.post_id 
      WHERE u.display_name = 'Joel Coehoorn' AND v.id > 0
      GROUP BY p.id) AS cv;
````

**5. Выгрузите все поля таблицы vote_types. Добавьте к таблице поле rank, в которое войдут номера записей в обратном порядке. Таблица должна быть отсортирована по полю id.**

````sql
SELECT *,
      ROW_NUMBER() OVER(ORDER BY id DESC) AS rank
FROM stackoverflow.vote_types
ORDER BY id;
````

**6. Отберите 10 пользователей, которые поставили больше всего голосов типа Close. Отобразите таблицу из двух полей: идентификатором пользователя и количеством голосов. Отсортируйте данные сначала по убыванию количества голосов, потом по убыванию значения идентификатора пользователя.**

````sql
SELECT client.user_id,
       client.count
FROM (SELECT v.user_id,
             COUNT(v.id) AS count,
             vt.name
      FROM stackoverflow.votes v 
      JOIN stackoverflow.vote_types vt ON v.vote_type_id = vt.id 
      GROUP BY v.user_id, vt.name
      ORDER BY COUNT(v.id) DESC, v.user_id DESC) AS client
WHERE name = 'Close'
LIMIT 10;
````

**7. Отберите 10 пользователей по количеству значков, полученных в период с 15 ноября по 15 декабря 2008 года включительно.
Отобразите несколько полей:**
  - идентификатор пользователя;
  - число значков;
  - место в рейтинге — чем больше значков, тем выше рейтинг.
    
**Пользователям, которые набрали одинаковое количество значков, присвойте одно и то же место в рейтинге.
Отсортируйте записи по количеству значков по убыванию, а затем по возрастанию значения идентификатора пользователя.**
     
````sql
SELECT *,
      DENSE_RANK() OVER (ORDER BY b.b_cnt DESC) AS rating
FROM (SELECT user_id,
             COUNT(id) AS b_cnt
      FROM stackoverflow.badges
      WHERE creation_date::date BETWEEN '2008-11-15' AND '2008-12-15' 
      GROUP BY user_id
      ORDER BY b_cnt DESC, user_id 
      LIMIT 10) as b;
````

**8. Сколько в среднем очков получает пост каждого пользователя?
     Сформируйте таблицу из следующих полей:**
- заголовок поста;
- идентификатор пользователя;
- число очков поста;
- среднее число очков пользователя за пост, округлённое до целого числа.
  
**Не учитывайте посты без заголовка, а также те, что набрали ноль очков.**
      
````sql   
SELECT title,
       user_id,
       score,
       ROUND(AVG(score) OVER(PARTITION BY user_id))
FROM stackoverflow.posts 
WHERE title IS NOT NULL AND score !=0;
````

**9. Отобразите заголовки постов, которые были написаны пользователями, получившими более 1000 значков. Посты без заголовков не должны попасть в список.**

````sql
SELECT title
FROM stackoverflow.posts 
WHERE user_id IN (SELECT user_id
                  FROM stackoverflow.badges
                  GROUP BY user_id 
                  HAVING COUNT(id)> 1000) AND title IS NOT NULL;
````

**10. Напишите запрос, который выгрузит данные о пользователях из Канады (англ. Canada). Разделите пользователей на три группы в зависимости от количества просмотров их профилей:**
- пользователям с числом просмотров больше либо равным 350 присвойте группу 1;
- пользователям с числом просмотров меньше 350, но больше либо равно 100 — группу 2;
- пользователям с числом просмотров меньше 100 — группу 3.
  
**Отобразите в итоговой таблице идентификатор пользователя, количество просмотров профиля и группу. Пользователи с количеством просмотров меньше либо равным нулю не должны войти в итоговую таблицу.**

````sql
SELECT id,
       views,
       CASE 
           WHEN views >= 350 THEN 1
           WHEN views < 100 THEN 3
           ELSE 2
       END 
FROM stackoverflow.users
WHERE location LIKE '%Canada%' AND views > 0;
````

**11. Дополните предыдущий запрос. Отобразите лидеров каждой группы — пользователей, которые набрали максимальное число просмотров в своей группе. Выведите поля с идентификатором пользователя, группой и количеством просмотров. Отсортируйте таблицу по убыванию просмотров, а затем по возрастанию значения идентификатора.**

````sql
WITH grp AS (SELECT g.id,
                    g.views,
                    g.group,
                    MAX(g.views) OVER (PARTITION BY g.group) AS max     
             FROM (SELECT id,
                          views,
                          CASE
                             WHEN views >= 350 THEN 1
                             WHEN views < 100 THEN 3
                             ELSE 2
                          END AS group
                   FROM stackoverflow.users
                   WHERE location LIKE '%United States%' AND views > 0) as g
              )
  
SELECT grp.id, 
       grp.views,  
       grp.group
FROM grp
WHERE grp.views = grp.max
ORDER BY grp.views DESC, grp.id;
````

**12. Посчитайте ежедневный прирост новых пользователей в ноябре 2008 года. Сформируйте таблицу с полями:**
- номер дня;
- число пользователей, зарегистрированных в этот день;
- сумму пользователей с накоплением.

````sql
SELECT *,
      SUM(us.cnt) OVER(ORDER BY us.days) AS sum
FROM (SELECT EXTRACT(DAY FROM creation_date::date) AS days,
             COUNT(id) AS cnt
      FROM stackoverflow.users 
      WHERE creation_date::date BETWEEN '2008-11-01' AND '2008-11-30' 
      GROUP BY EXTRACT(DAY FROM creation_date::date)) AS us;
````

**13. Для каждого пользователя, который написал хотя бы один пост, найдите интервал между регистрацией и временем создания первого поста.       Отобразите:**
- идентификатор пользователя;
- разницу во времени между регистрацией и первым постом.
                
````sql                
SELECT us.user_id,
       (us.first_date - us.registration_date) AS diff
FROM (SELECT DISTINCT p.user_id,
             MIN(p.creation_date) OVER(PARTITION BY p.user_id) AS first_date,
             u.creation_date AS registration_date
      FROM stackoverflow.posts p 
      JOIN stackoverflow.users u ON p.user_id=u.id) AS us;
````
***

**14. Выведите общую сумму просмотров у постов, опубликованных в каждый месяц 2008 года. Если данных за какой-либо месяц в базе нет, такой месяц можно пропустить. Результат отсортируйте по убыванию общего количества просмотров.**

````sql   
SELECT DATE_TRUNC('month', creation_date)::date AS mnth,
      SUM(views_count) as total_quantity
FROM stackoverflow.posts 
GROUP BY  mnth
ORDER BY total_quantity DESC;
````
